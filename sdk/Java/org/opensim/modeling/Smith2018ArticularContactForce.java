/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 * This Force component models the contact between a pair of triangulated surface<br>
 * meshes (.vtp, .stl, .obj). It was orginially designed to represent articular <br>
 * contact between cartilage, mensici, or joint implants [1], but is <br>
 * generalizable so it could also represent foot-floor contact or a skin-device <br>
 * interfaces etc. The formulation of the contact model has previously been <br>
 * called an elastic foundation model [2] or discrete element analysis [3,4]. <br>
 * In this implementation, non-deforming triangulated meshes are allowed to <br>
 * interpenetrate and the proximity (distance between the meshes) is calculated <br>
 * for each triangle. For every triangle with a positive proximity (ie triangle <br>
 * interpenetrated the opposing mesh), the contact pressure on the triangle face <br>
 * is then calculated based on the proximity and material properties. This <br>
 * formulation is much faster than a finite element approach, but only calculates <br>
 * the contact pressures on the mesh surface and not the internal stresses. <br>
 * Additionally, it provides a simplifed representation of the contact as the <br>
 * meshes do not deform, but instead are geometrically rigid (ie the vertices <br>
 * within a mesh do not move relative to each other), but the contacting mesh <br>
 * pair are allowed to interpenetrate.<br>
 * <br>
 * The while the force calculatation is similar to the ElasticFoundationForce<br>
 * component, the Smith2018ArticularContactForce provides a different <br>
 * parameterization of the relationship between the overlap depth and material <br>
 * properties to calculate the contact pressure. Additionally, it provides the <br>
 * proximity, pressure, and potential_energy for each mesh triangle as an output <br>
 * so that maps of these calculated values on the mesh surface can be visualized. <br>
 * Finally, it provides improved computational performance through a different <br>
 * collision detection method.<br>
 * <br>
 * To calculate the pressure for each triangle, it is necessary to detect the <br>
 * mesh triangles that are interpenetrating (commonly called contact or collision<br>
 * detection in computer graphics literature) and calculate the proximity. This <br>
 * task is extremely slow if a brute force approach is applied to check every <br>
 * triangle in one mesh against every triangle in another mesh. Smith et al, <br>
 * CMBBE I&amp;V, 2018 [1] introduced a method to efficiently detect contact between <br>
 * triangular meshes using Oriented Bounding Boxes (OBBs, a common approach in <br>
 * computer graphics) and several additional speed-ups that leverage the fact <br>
 * that changes in contact between timesteps are generally small. This approach <br>
 * has been implemented in the Smith2018ArticularContactForce component along <br>
 * with some additional features.<br>
 * <br>
 * Two articulating triangular meshes are defined as Smith2018ContactMesh<br>
 * components (Sockets: casting_mesh and target_mesh). These meshes are fixed to<br>
 * bodies in the model, and thus their relative poses are determined by the<br>
 * model coordinates. To detect contact, a normal ray is cast from the center of<br>
 * each triangle in the casting mesh towards the overlapping target<br>
 * mesh. Ray intersection tests are then performed against an Oriented Bounding<br>
 * Box tree constructed around the target mesh. This algorithm is implemented in<br>
 * the computeMeshProximity() function with the OBB construction and ray<br>
 * intersection queries managed by the Smith2018ContactMesh.<br>
 * <br>
 * <img src=fig_Smith2018ArticularContactForce_contact_detection.png alt=width=600px/><br>
 * <br>
 * The major speed-up in the algorithm leverages the fact that changes in joint<br>
 * coordinates and thus contact patterns between time steps are generally small. <br>
 * Thus, after reposing the meshes, (i.e. realizePosition()) each<br>
 * triangle in the casting mesh is tested against the contacting target triangle<br>
 * from the previous pose. Additional speed-up can be gained by casting the normal<br>
 * ray in both directions (by setting min_proximity to a negative value), so <br>
 * even some of the out-of-contact triangles are "remembered". If the previous <br>
 * contacting triangle test fails, the casting ray is checked against the <br>
 * neighboring triangles (those that share a vertex) in the target mesh. Then if <br>
 * this test fails, the expensive casting ray--OBB test is performed. If the <br>
 * meshes were not in contact at the previous time step this does not cause an <br>
 * issue, just a slower solution, as here the ray-OBB tests will be peformed for <br>
 * every triangle in the casting_mesh.  <br>
 * <br>
 * <br>
 * # Swapping the contact meshes changes the resulting forces<br>
 * <br>
 * The ray casting is only performed from the casting_mesh towards the <br>
 * target_mesh. Thus, a pressure map is only generated for the casting_mesh. <br>
 * A force vector is computed for each triangle in the casting_mesh using<br>
 * Force = -normal*area*pressure, and the resultant force of<br>
 * all triangle forces is applied to the body to which the casting_mesh is<br>
 * attached. An equal and opposite force is applied to the body to which the<br>
 * target_mesh is attached. The important ramification of this is that if the<br>
 * casting_mesh and target_mesh are switched, the simulation results will NOT be<br>
 * exactly the same. For best performance, the casting_mesh should be set to the<br>
 * mesh that contains the smaller number of triangles.<br>
 * <br>
 * As it is still useful to visualize the proximity and<br>
 * pressure maps for the target_mesh, and in most situations the resultant force<br>
 * from the target_mesh are very close to the mirrored casting_mesh resultant<br>
 * force, there is a ModelingOption named "flip_meshes" that will cause the ray<br>
 * casting to also be performed from the target_mesh to calculate triangle<br>
 * proximity and pressure values. Note the applied contact force in this case is<br>
 * still only that calculated for the casting_mesh, and the time needed for <br>
 * collision detection is approximately doubled. <br>
 * <br>
 * # Potential Pitfalls<br>
 * <img src=fig_Smith2018ArticularContactForce_pitfalls.png alt=width=600px/><br>
 * <br>
 * Case 1<br>
 * The casting_mesh mesh has significant curvature and the material properties <br>
 * are set in a manner that results in a compliment contact where large <br>
 * interpenetrations with curvature may occur. In this scenario,<br>
 * the distance along the normal ray from the casting_mesh to the target_mesh<br>
 * may be unrealistically large, resulting in high contact pressures. If only <br>
 * one mesh has high curvature, then this mesh can be defined as the target_mesh<br>
 * and the excessive proximity values are avoided. Another potential solution is<br>
 * to ensure that the initial positions of the meshes are set so that there is <br>
 * minimal or no contact, thus as the simulation progresses the increasing <br>
 * contact pressures will prevent significant interpentration of the meshes. <br>
 * <br>
 * Case 2<br>
 * Another pitfall of highly curved meshes is the potential for false contact <br>
 * detection as shown in the figure. Here, a triangle on the side of the patellar<br>
 * cartilage will be incorrectly identified as in contact with the femur. This <br>
 * problem can be avoided by setting min_proximity and max_proximity properties<br>
 * to values that limit the potential contact search area to feasible locations <br>
 * for your application. The min_proximity and max_proximity properties limit the <br>
 * search region for a contact triangle along the ray cast from the casting_mesh.<br>
 * The min_proximity can be set to a negative value if you would like proximity <br>
 * maps for the out of contact triangles. For example, if you are visualizing <br>
 * kinematics measured with fluoroscopy and only have meshes of the bones, using <br>
 * a negative min_proximity enables the distance between the subcondral surfaces <br>
 * to be calculated for each triangle in the casting_mesh.<br>
 * <br>
 * Case 3<br>
 * To reduce the number of triangles in the Smith2018ContactMesh and thus speed<br>
 * up the collision detection, the meshes do not need to be closed surfaces<br>
 * (water tight). However, this can cause issues if the initial positions of the <br>
 * meshes are set improperly or the positions of the meshes within a simulation <br>
 * progress to infeasible configurations. The figure depicts that the patella <br>
 * has been spun 180*, so if soft tissues pull the patella straight into the <br>
 * femur, no contact will be detected because the backside of the patella will <br>
 * collide with the femur. However, while the meshes do not need to be closed,<br>
 * they can be closed to avoid this issue for applications such as simulating the<br>
 * contact between a spinning ball bouncing on a surface.<br>
 * <br>
 * <br>
 * # The pressure-depth relationship<br>
 * <br>
 * The relationship between overlap depth and pressure can be either linear or<br>
 * non-linear, depending on the value of the elastic_foundation_formulation<br>
 * property. The implemented equations are those proposed in Bei and Fregly, Med<br>
 * Eng Phys, 2004 [2]:<br>
 * <br>
 * Linear:<br>
 *  
   P = E\frac{(1-\nu)}{(1 + \nu)(1-2\nu)}\frac{d}{h}
<br>
 * <br>
 * Non-Linear:<br>
 *  
  P = -E\frac{(1-\nu)}{(1 + \nu)(1-2\nu)}\ln{\left(1-\frac{d}{h}\right)}
<br>
 * <br>
 * Where:<br>
 *  -   P : pressure<br>
 *  -   E : elastic modulus<br>
 *  -   \nu : Poisson's ratio<br>
 *  -   d : depth of overlap<br>
 *  -   h : height (i.e., thickness) of the elastic layer<br>
 * <br>
 * # Material/mesh properties<br>
 * <br>
 * The original Bei and Fregly formulation assumes that a rigid object is<br>
 * contacting an object with a thin elastic layer. This assumption is appropriate<br>
 * when modeling joint replacements where a metal component (rigid) contacts a<br>
 * polyethylene component (elastic). To model cartilage-cartilage contact, this<br>
 * approach requires that the two cartilage layers are lumped together into one<br>
 * elastic layer, necessitating that a constant thickness, elastic modulus, and<br>
 * Poisson's ratio is assumed for each contacting triangle pair. Thus the total<br>
 * overlap depth is split equally between each triangle contact pair. As<br>
 * cartilage-cartilage contact often involves articulations between cartilage<br>
 * surfaces with varying thickness and material properties, the Bei and Fregly<br>
 * approach was extended to accommodate variable properties. The<br>
 * use_lumped_contact_model property controls whether the constant property or<br>
 * variable property formulation is used. <br>
 * <br>
 * <img src=fig_Smith2018ArticularContactForce_lumped_model.png alt=width=600px/><br>
 * <br>
 * The variable property formulation is described in Zevenbergen et al,<br>
 * PLOS One, 2018 [5]. Here, the following system of four equations must be<br>
 * solved to obtain the local overlap depth (proximity) and pressure for the<br>
 * casting and target triangles.<br>
 * <br>
 *  
 \begin{align}
  P_\mathrm{casting} &= f(E,\nu,h,d_\mathrm{casting}) \\
  P_\mathrm{target} &= f(E,\nu,h,d_\mathrm{target}) \\
  P_\mathrm{casting} &= P_\mathrm{target} \\
  d &= d_\mathrm{casting} + d_\mathrm{target}
  \end{align}
<br>
 * <br>
 * Here, the first two equations use the Bei and Fregly elastic foundation model<br>
 * (linear or non-linear) to define the relationship between the local mesh<br>
 * properties, local overlap depth and computed pressure. The third equation is a<br>
 * force equilibrium, assuming that the force applied to a pair of contacting<br>
 * triangles is equal and opposite. This formulation further assumes that the<br>
 * triangles in contact have the same area. The fourth equation states that the<br>
 * total overlap depth of the meshes (which is readily calculated) is the sum of<br>
 * the local overlap depths of the two elastic layers in contact.<br>
 * <br>
 * This system of equations can be solved analytically if the linear pressure-<br>
 * depth relationship is used. If the non-linear relationship is used, the<br>
 * system of equations is solved using a numerical solver.<br>
 * <br>
 * # Outputs<br>
 * <br>
 * This component has some outputs such as triangle_proximity, triangle_pressure,<br>
 * and triangle_potential_energy that return a SimTK::Vector (size = number of <br>
 * triangles) with a value corresponding to each triangle face in the respective <br>
 * target or casting mesh.<br>
 * There are also "summary" outputs that return values associated with the entire <br>
 * mesh such as contact area, mean/max proximity/pressure, center of<br>
 * proximity/pressure etc. Finally, there are regional summary outputs which<br>
 * return a SimTK::Vector (size = 6). Here, the entries in the vector reflect the<br>
 * summary metrics corresponding to subset of mesh triangles located in six <br>
 * specific regions. These six regions are defined as the subset of mesh triangles <br>
 * whose center is located in the half space [+x, -x, +y, -y, +z, -z] in the <br>
 * local mesh coordinate system. If the mesh coordinate system is aligned with <br>
 * anatomical axes, then this enables simulation results to be more readily <br>
 * interpreted. For example, when performing simulations of the knee, if the <br>
 * z axis is aligned to the medial-lateral axis, points medially, and the origin <br>
 * is located between the femoral condyles, then the regional outputs <br>
 * corresponding to +z and -z will summarize the mesh triangles located on the <br>
 * medial and lateral condyles and thus enable comparisons of the loading in the <br>
 * medial and lateral compartments.<br>
 * <br>
 * All outputs are reported in the local mesh reference frame (ie the reference<br>
 * frame of the mesh_file. The ContactForce and ContactMoment outputs are <br>
 * expressed in this frame and calculated at the origin of this frame.). <br>
 * <br>
 * # References<br>
 * <br>
 *    [1] Smith, C. R., Won Choi, K., Negrut, D., &amp; Thelen, D. G. (2018).<br>
 *        Efficient computation of cartilage contact pressures within dynamic<br>
 *        simulations of movement. Computer Methods in Biomechanics and<br>
 *        Biomedical Engineering: Imaging &amp; Visualization, 6(5), 491-498.<br>
 * <br>
 *    [2] Bei, Y., &amp; Fregly, B. J. (2004). Multibody dynamic simulation of knee<br>
 *        contact mechanics. Medical engineering &amp; physics, 26(9), 777-789.<br>
 * <br>
 *    [3] Volokh, K. Y., Chao, E. Y. S., &amp; Armand, M. (2007). On foundations of<br>
 *        discrete element analysis of contact in diarthrodial joints. Molecular<br>
 *        &amp; cellular biomechanics: MCB, 4(2), 67.<br>
 * <br>
 *    [4] Abraham, C. L., Maas, S. A., Weiss, J. A., Ellis, B. J., Peters, C.<br>
 *        L., &amp; Anderson, A. E. (2013). A new discrete element analysis method<br>
 *        for predicting hip joint contact stresses. Journal of biomechanics,<br>
 *        46(6), 1121-1127.<br>
 * <br>
 *    [5] Zevenbergen, L., Smith, C. R., Van Rossom, S., Thelen, D. G., Famaey,<br>
 *        N., Vander Sloten, J., &amp; Jonkers, I. (2018). Cartilage defect location<br>
 *        and stiffness predispose the tibiofemoral joint to aberrant loading<br>
 *        conditions during stance phase of gait. PloS one, 13(10), e0205842.
 */
public class Smith2018ArticularContactForce extends Force {
  private transient long swigCPtr;

  public Smith2018ArticularContactForce(long cPtr, boolean cMemoryOwn) {
    super(opensimSimulationJNI.Smith2018ArticularContactForce_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  public static long getCPtr(Smith2018ArticularContactForce obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimulationJNI.delete_Smith2018ArticularContactForce(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  public static Smith2018ArticularContactForce safeDownCast(OpenSimObject obj) {
    long cPtr = opensimSimulationJNI.Smith2018ArticularContactForce_safeDownCast(OpenSimObject.getCPtr(obj), obj);
    return (cPtr == 0) ? null : new Smith2018ArticularContactForce(cPtr, false);
  }

  public void assign(OpenSimObject aObject) {
    opensimSimulationJNI.Smith2018ArticularContactForce_assign(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  public static String getClassName() {
    return opensimSimulationJNI.Smith2018ArticularContactForce_getClassName();
  }

  public OpenSimObject clone() {
    long cPtr = opensimSimulationJNI.Smith2018ArticularContactForce_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new Smith2018ArticularContactForce(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimSimulationJNI.Smith2018ArticularContactForce_getConcreteClassName(swigCPtr, this);
  }

  public void copyProperty_min_proximity(Smith2018ArticularContactForce source) {
    opensimSimulationJNI.Smith2018ArticularContactForce_copyProperty_min_proximity(swigCPtr, this, Smith2018ArticularContactForce.getCPtr(source), source);
  }

  public double get_min_proximity(int i) {
    return opensimSimulationJNI.Smith2018ArticularContactForce_get_min_proximity__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_min_proximity(int i) {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Smith2018ArticularContactForce_upd_min_proximity__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_min_proximity(int i, double value) {
    opensimSimulationJNI.Smith2018ArticularContactForce_set_min_proximity__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_min_proximity(double value) {
    return opensimSimulationJNI.Smith2018ArticularContactForce_append_min_proximity(swigCPtr, this, value);
  }

  public void constructProperty_min_proximity(double initValue) {
    opensimSimulationJNI.Smith2018ArticularContactForce_constructProperty_min_proximity(swigCPtr, this, initValue);
  }

  public double get_min_proximity() {
    return opensimSimulationJNI.Smith2018ArticularContactForce_get_min_proximity__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_min_proximity() {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Smith2018ArticularContactForce_upd_min_proximity__SWIG_1(swigCPtr, this), false);
  }

  public void set_min_proximity(double value) {
    opensimSimulationJNI.Smith2018ArticularContactForce_set_min_proximity__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_max_proximity(Smith2018ArticularContactForce source) {
    opensimSimulationJNI.Smith2018ArticularContactForce_copyProperty_max_proximity(swigCPtr, this, Smith2018ArticularContactForce.getCPtr(source), source);
  }

  public double get_max_proximity(int i) {
    return opensimSimulationJNI.Smith2018ArticularContactForce_get_max_proximity__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_max_proximity(int i) {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Smith2018ArticularContactForce_upd_max_proximity__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_max_proximity(int i, double value) {
    opensimSimulationJNI.Smith2018ArticularContactForce_set_max_proximity__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_max_proximity(double value) {
    return opensimSimulationJNI.Smith2018ArticularContactForce_append_max_proximity(swigCPtr, this, value);
  }

  public void constructProperty_max_proximity(double initValue) {
    opensimSimulationJNI.Smith2018ArticularContactForce_constructProperty_max_proximity(swigCPtr, this, initValue);
  }

  public double get_max_proximity() {
    return opensimSimulationJNI.Smith2018ArticularContactForce_get_max_proximity__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_max_proximity() {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Smith2018ArticularContactForce_upd_max_proximity__SWIG_1(swigCPtr, this), false);
  }

  public void set_max_proximity(double value) {
    opensimSimulationJNI.Smith2018ArticularContactForce_set_max_proximity__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_elastic_foundation_formulation(Smith2018ArticularContactForce source) {
    opensimSimulationJNI.Smith2018ArticularContactForce_copyProperty_elastic_foundation_formulation(swigCPtr, this, Smith2018ArticularContactForce.getCPtr(source), source);
  }

  public String get_elastic_foundation_formulation(int i) {
    return opensimSimulationJNI.Smith2018ArticularContactForce_get_elastic_foundation_formulation__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_std__string upd_elastic_foundation_formulation(int i) {
    return new SWIGTYPE_p_std__string(opensimSimulationJNI.Smith2018ArticularContactForce_upd_elastic_foundation_formulation__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_elastic_foundation_formulation(int i, String value) {
    opensimSimulationJNI.Smith2018ArticularContactForce_set_elastic_foundation_formulation__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_elastic_foundation_formulation(String value) {
    return opensimSimulationJNI.Smith2018ArticularContactForce_append_elastic_foundation_formulation(swigCPtr, this, value);
  }

  public void constructProperty_elastic_foundation_formulation(String initValue) {
    opensimSimulationJNI.Smith2018ArticularContactForce_constructProperty_elastic_foundation_formulation(swigCPtr, this, initValue);
  }

  public String get_elastic_foundation_formulation() {
    return opensimSimulationJNI.Smith2018ArticularContactForce_get_elastic_foundation_formulation__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_std__string upd_elastic_foundation_formulation() {
    return new SWIGTYPE_p_std__string(opensimSimulationJNI.Smith2018ArticularContactForce_upd_elastic_foundation_formulation__SWIG_1(swigCPtr, this), false);
  }

  public void set_elastic_foundation_formulation(String value) {
    opensimSimulationJNI.Smith2018ArticularContactForce_set_elastic_foundation_formulation__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_use_lumped_contact_model(Smith2018ArticularContactForce source) {
    opensimSimulationJNI.Smith2018ArticularContactForce_copyProperty_use_lumped_contact_model(swigCPtr, this, Smith2018ArticularContactForce.getCPtr(source), source);
  }

  public boolean get_use_lumped_contact_model(int i) {
    return opensimSimulationJNI.Smith2018ArticularContactForce_get_use_lumped_contact_model__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_bool upd_use_lumped_contact_model(int i) {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Smith2018ArticularContactForce_upd_use_lumped_contact_model__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_use_lumped_contact_model(int i, boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce_set_use_lumped_contact_model__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_use_lumped_contact_model(boolean value) {
    return opensimSimulationJNI.Smith2018ArticularContactForce_append_use_lumped_contact_model(swigCPtr, this, value);
  }

  public void constructProperty_use_lumped_contact_model(boolean initValue) {
    opensimSimulationJNI.Smith2018ArticularContactForce_constructProperty_use_lumped_contact_model(swigCPtr, this, initValue);
  }

  public boolean get_use_lumped_contact_model() {
    return opensimSimulationJNI.Smith2018ArticularContactForce_get_use_lumped_contact_model__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_bool upd_use_lumped_contact_model() {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Smith2018ArticularContactForce_upd_use_lumped_contact_model__SWIG_1(swigCPtr, this), false);
  }

  public void set_use_lumped_contact_model(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce_set_use_lumped_contact_model__SWIG_1(swigCPtr, this, value);
  }

  public void setPropertyIndex_socket_target_mesh(SWIGTYPE_p_PropertyIndex value) {
    opensimSimulationJNI.Smith2018ArticularContactForce_PropertyIndex_socket_target_mesh_set(swigCPtr, this, SWIGTYPE_p_PropertyIndex.getCPtr(value));
  }

  public SWIGTYPE_p_PropertyIndex getPropertyIndex_socket_target_mesh() {
    return new SWIGTYPE_p_PropertyIndex(opensimSimulationJNI.Smith2018ArticularContactForce_PropertyIndex_socket_target_mesh_get(swigCPtr, this), true);
  }

  public void connectSocket_target_mesh(OpenSimObject object) {
    opensimSimulationJNI.Smith2018ArticularContactForce_connectSocket_target_mesh(swigCPtr, this, OpenSimObject.getCPtr(object), object);
  }

  public void setPropertyIndex_socket_casting_mesh(SWIGTYPE_p_PropertyIndex value) {
    opensimSimulationJNI.Smith2018ArticularContactForce_PropertyIndex_socket_casting_mesh_set(swigCPtr, this, SWIGTYPE_p_PropertyIndex.getCPtr(value));
  }

  public SWIGTYPE_p_PropertyIndex getPropertyIndex_socket_casting_mesh() {
    return new SWIGTYPE_p_PropertyIndex(opensimSimulationJNI.Smith2018ArticularContactForce_PropertyIndex_socket_casting_mesh_get(swigCPtr, this), true);
  }

  public void connectSocket_casting_mesh(OpenSimObject object) {
    opensimSimulationJNI.Smith2018ArticularContactForce_connectSocket_casting_mesh(swigCPtr, this, OpenSimObject.getCPtr(object), object);
  }

  public void set_has_output_target_num_contacting_triangles(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_num_contacting_triangles_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_num_contacting_triangles() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_num_contacting_triangles_get(swigCPtr, this);
  }

  public void set_has_output_casting_num_contacting_triangles(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_num_contacting_triangles_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_num_contacting_triangles() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_num_contacting_triangles_get(swigCPtr, this);
  }

  public void set_has_output_target_triangle_proximity(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_triangle_proximity_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_triangle_proximity() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_triangle_proximity_get(swigCPtr, this);
  }

  public void set_has_output_casting_triangle_proximity(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_triangle_proximity_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_triangle_proximity() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_triangle_proximity_get(swigCPtr, this);
  }

  public void set_has_output_target_triangle_pressure(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_triangle_pressure_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_triangle_pressure() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_triangle_pressure_get(swigCPtr, this);
  }

  public void set_has_output_casting_triangle_pressure(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_triangle_pressure_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_triangle_pressure() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_triangle_pressure_get(swigCPtr, this);
  }

  public void set_has_output_target_triangle_potential_energy(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_triangle_potential_energy_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_triangle_potential_energy() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_triangle_potential_energy_get(swigCPtr, this);
  }

  public void set_has_output_casting_triangle_potential_energy(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_triangle_potential_energy_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_triangle_potential_energy() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_triangle_potential_energy_get(swigCPtr, this);
  }

  public void set_has_output_target_total_contact_area(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_total_contact_area_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_total_contact_area() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_total_contact_area_get(swigCPtr, this);
  }

  public void set_has_output_casting_total_contact_area(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_total_contact_area_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_total_contact_area() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_total_contact_area_get(swigCPtr, this);
  }

  public void set_has_output_target_regional_contact_area(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_regional_contact_area_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_regional_contact_area() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_regional_contact_area_get(swigCPtr, this);
  }

  public void set_has_output_casting_regional_contact_area(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_regional_contact_area_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_regional_contact_area() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_regional_contact_area_get(swigCPtr, this);
  }

  public void set_has_output_target_total_mean_proximity(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_total_mean_proximity_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_total_mean_proximity() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_total_mean_proximity_get(swigCPtr, this);
  }

  public void set_has_output_casting_total_mean_proximity(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_total_mean_proximity_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_total_mean_proximity() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_total_mean_proximity_get(swigCPtr, this);
  }

  public void set_has_output_target_regional_mean_proximity(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_regional_mean_proximity_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_regional_mean_proximity() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_regional_mean_proximity_get(swigCPtr, this);
  }

  public void set_has_output_casting_regional_mean_proximity(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_regional_mean_proximity_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_regional_mean_proximity() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_regional_mean_proximity_get(swigCPtr, this);
  }

  public void set_has_output_target_total_max_proximity(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_total_max_proximity_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_total_max_proximity() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_total_max_proximity_get(swigCPtr, this);
  }

  public void set_has_output_casting_total_max_proximity(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_total_max_proximity_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_total_max_proximity() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_total_max_proximity_get(swigCPtr, this);
  }

  public void set_has_output_target_regional_max_proximity(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_regional_max_proximity_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_regional_max_proximity() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_regional_max_proximity_get(swigCPtr, this);
  }

  public void set_has_output_casting_regional_max_proximity(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_regional_max_proximity_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_regional_max_proximity() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_regional_max_proximity_get(swigCPtr, this);
  }

  public void set_has_output_target_total_mean_pressure(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_total_mean_pressure_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_total_mean_pressure() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_total_mean_pressure_get(swigCPtr, this);
  }

  public void set_has_output_casting_total_mean_pressure(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_total_mean_pressure_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_total_mean_pressure() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_total_mean_pressure_get(swigCPtr, this);
  }

  public void set_has_output_target_regional_mean_pressure(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_regional_mean_pressure_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_regional_mean_pressure() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_regional_mean_pressure_get(swigCPtr, this);
  }

  public void set_has_output_casting_regional_mean_pressure(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_regional_mean_pressure_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_regional_mean_pressure() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_regional_mean_pressure_get(swigCPtr, this);
  }

  public void set_has_output_target_total_max_pressure(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_total_max_pressure_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_total_max_pressure() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_total_max_pressure_get(swigCPtr, this);
  }

  public void set_has_output_casting_total_max_pressure(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_total_max_pressure_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_total_max_pressure() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_total_max_pressure_get(swigCPtr, this);
  }

  public void set_has_output_target_regional_max_pressure(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_regional_max_pressure_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_regional_max_pressure() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_regional_max_pressure_get(swigCPtr, this);
  }

  public void set_has_output_casting_regional_max_pressure(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_regional_max_pressure_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_regional_max_pressure() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_regional_max_pressure_get(swigCPtr, this);
  }

  public void set_has_output_target_total_center_of_proximity(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_total_center_of_proximity_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_total_center_of_proximity() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_total_center_of_proximity_get(swigCPtr, this);
  }

  public void set_has_output_casting_total_center_of_proximity(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_total_center_of_proximity_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_total_center_of_proximity() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_total_center_of_proximity_get(swigCPtr, this);
  }

  public void set_has_output_target_regional_center_of_proximity(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_regional_center_of_proximity_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_regional_center_of_proximity() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_regional_center_of_proximity_get(swigCPtr, this);
  }

  public void set_has_output_casting_regional_center_of_proximity(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_regional_center_of_proximity_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_regional_center_of_proximity() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_regional_center_of_proximity_get(swigCPtr, this);
  }

  public void set_has_output_target_total_center_of_pressure(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_total_center_of_pressure_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_total_center_of_pressure() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_total_center_of_pressure_get(swigCPtr, this);
  }

  public void set_has_output_casting_total_center_of_pressure(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_total_center_of_pressure_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_total_center_of_pressure() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_total_center_of_pressure_get(swigCPtr, this);
  }

  public void set_has_output_target_regional_center_of_pressure(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_regional_center_of_pressure_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_regional_center_of_pressure() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_regional_center_of_pressure_get(swigCPtr, this);
  }

  public void set_has_output_casting_regional_center_of_pressure(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_regional_center_of_pressure_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_regional_center_of_pressure() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_regional_center_of_pressure_get(swigCPtr, this);
  }

  public void set_has_output_target_total_contact_force(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_total_contact_force_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_total_contact_force() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_total_contact_force_get(swigCPtr, this);
  }

  public void set_has_output_casting_total_contact_force(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_total_contact_force_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_total_contact_force() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_total_contact_force_get(swigCPtr, this);
  }

  public void set_has_output_target_regional_contact_force(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_regional_contact_force_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_regional_contact_force() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_regional_contact_force_get(swigCPtr, this);
  }

  public void set_has_output_casting_regional_contact_force(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_regional_contact_force_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_regional_contact_force() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_regional_contact_force_get(swigCPtr, this);
  }

  public void set_has_output_target_total_contact_moment(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_total_contact_moment_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_total_contact_moment() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_total_contact_moment_get(swigCPtr, this);
  }

  public void set_has_output_casting_total_contact_moment(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_total_contact_moment_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_total_contact_moment() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_total_contact_moment_get(swigCPtr, this);
  }

  public void set_has_output_target_regional_contact_moment(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_regional_contact_moment_set(swigCPtr, this, value);
  }

  public boolean get_has_output_target_regional_contact_moment() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_target_regional_contact_moment_get(swigCPtr, this);
  }

  public void set_has_output_casting_regional_contact_moment(boolean value) {
    opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_regional_contact_moment_set(swigCPtr, this, value);
  }

  public boolean get_has_output_casting_regional_contact_moment() {
    return opensimSimulationJNI.Smith2018ArticularContactForce__has_output_casting_regional_contact_moment_get(swigCPtr, this);
  }

  public Smith2018ArticularContactForce() {
    this(opensimSimulationJNI.new_Smith2018ArticularContactForce__SWIG_0(), true);
  }

  public Smith2018ArticularContactForce(String name, Smith2018ContactMesh target_mesh, Smith2018ContactMesh casting_mesh) {
    this(opensimSimulationJNI.new_Smith2018ArticularContactForce__SWIG_1(name, Smith2018ContactMesh.getCPtr(target_mesh), target_mesh, Smith2018ContactMesh.getCPtr(casting_mesh), casting_mesh), true);
  }

  public int getTargetNumContactingTriangles(State state) {
    return opensimSimulationJNI.Smith2018ArticularContactForce_getTargetNumContactingTriangles(swigCPtr, this, State.getCPtr(state), state);
  }

  public int getCastingNumContactingTriangles(State state) {
    return opensimSimulationJNI.Smith2018ArticularContactForce_getCastingNumContactingTriangles(swigCPtr, this, State.getCPtr(state), state);
  }

  public Vector getTargetTriangleProximity(State state) {
    return new Vector(opensimSimulationJNI.Smith2018ArticularContactForce_getTargetTriangleProximity(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public Vector getCastingTriangleProximity(State state) {
    return new Vector(opensimSimulationJNI.Smith2018ArticularContactForce_getCastingTriangleProximity(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public Vector getTargetTrianglePressure(State state) {
    return new Vector(opensimSimulationJNI.Smith2018ArticularContactForce_getTargetTrianglePressure(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public Vector getCastingTrianglePressure(State state) {
    return new Vector(opensimSimulationJNI.Smith2018ArticularContactForce_getCastingTrianglePressure(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public Vector getTargetTrianglePotentialEnergy(State state) {
    return new Vector(opensimSimulationJNI.Smith2018ArticularContactForce_getTargetTrianglePotentialEnergy(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public Vector getCastingTrianglePotentialEnergy(State state) {
    return new Vector(opensimSimulationJNI.Smith2018ArticularContactForce_getCastingTrianglePotentialEnergy(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public double getTargetTotalContactArea(State state) {
    return opensimSimulationJNI.Smith2018ArticularContactForce_getTargetTotalContactArea(swigCPtr, this, State.getCPtr(state), state);
  }

  public double getCastingTotalContactArea(State state) {
    return opensimSimulationJNI.Smith2018ArticularContactForce_getCastingTotalContactArea(swigCPtr, this, State.getCPtr(state), state);
  }

  public Vector getTargetRegionalContactArea(State state) {
    return new Vector(opensimSimulationJNI.Smith2018ArticularContactForce_getTargetRegionalContactArea(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public Vector getCastingRegionalContactArea(State state) {
    return new Vector(opensimSimulationJNI.Smith2018ArticularContactForce_getCastingRegionalContactArea(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public double getTargetTotalMeanProximity(State state) {
    return opensimSimulationJNI.Smith2018ArticularContactForce_getTargetTotalMeanProximity(swigCPtr, this, State.getCPtr(state), state);
  }

  public double getCastingTotalMeanProximity(State state) {
    return opensimSimulationJNI.Smith2018ArticularContactForce_getCastingTotalMeanProximity(swigCPtr, this, State.getCPtr(state), state);
  }

  public Vector getTargetRegionalMeanProximity(State state) {
    return new Vector(opensimSimulationJNI.Smith2018ArticularContactForce_getTargetRegionalMeanProximity(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public Vector getCastingRegionalMeanProximity(State state) {
    return new Vector(opensimSimulationJNI.Smith2018ArticularContactForce_getCastingRegionalMeanProximity(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public double getTargetTotalMaxProximity(State state) {
    return opensimSimulationJNI.Smith2018ArticularContactForce_getTargetTotalMaxProximity(swigCPtr, this, State.getCPtr(state), state);
  }

  public double getCastingTotalMaxProximity(State state) {
    return opensimSimulationJNI.Smith2018ArticularContactForce_getCastingTotalMaxProximity(swigCPtr, this, State.getCPtr(state), state);
  }

  public Vector getTargetRegionalMaxProximity(State state) {
    return new Vector(opensimSimulationJNI.Smith2018ArticularContactForce_getTargetRegionalMaxProximity(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public Vector getCastingRegionalMaxProximity(State state) {
    return new Vector(opensimSimulationJNI.Smith2018ArticularContactForce_getCastingRegionalMaxProximity(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public double getTargetTotalMeanPressure(State state) {
    return opensimSimulationJNI.Smith2018ArticularContactForce_getTargetTotalMeanPressure(swigCPtr, this, State.getCPtr(state), state);
  }

  public double getCastingTotalMeanPressure(State state) {
    return opensimSimulationJNI.Smith2018ArticularContactForce_getCastingTotalMeanPressure(swigCPtr, this, State.getCPtr(state), state);
  }

  public Vector getTargetRegionalMeanPressure(State state) {
    return new Vector(opensimSimulationJNI.Smith2018ArticularContactForce_getTargetRegionalMeanPressure(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public Vector getCastingRegionalMeanPressure(State state) {
    return new Vector(opensimSimulationJNI.Smith2018ArticularContactForce_getCastingRegionalMeanPressure(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public double getTargetTotalMaxPressure(State state) {
    return opensimSimulationJNI.Smith2018ArticularContactForce_getTargetTotalMaxPressure(swigCPtr, this, State.getCPtr(state), state);
  }

  public double getCastingTotalMaxPressure(State state) {
    return opensimSimulationJNI.Smith2018ArticularContactForce_getCastingTotalMaxPressure(swigCPtr, this, State.getCPtr(state), state);
  }

  public Vector getTargetRegionalMaxPressure(State state) {
    return new Vector(opensimSimulationJNI.Smith2018ArticularContactForce_getTargetRegionalMaxPressure(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public Vector getCastingRegionalMaxPressure(State state) {
    return new Vector(opensimSimulationJNI.Smith2018ArticularContactForce_getCastingRegionalMaxPressure(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public Vec3 getTargetTotalCenterOfProximity(State state) {
    return new Vec3(opensimSimulationJNI.Smith2018ArticularContactForce_getTargetTotalCenterOfProximity(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public Vec3 getCastingTotalCenterOfProximity(State state) {
    return new Vec3(opensimSimulationJNI.Smith2018ArticularContactForce_getCastingTotalCenterOfProximity(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public VectorVec3 getTargetRegionalCenterOfProximity(State state) {
    return new VectorVec3(opensimSimulationJNI.Smith2018ArticularContactForce_getTargetRegionalCenterOfProximity(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public VectorVec3 getCastingRegionalCenterOfProximity(State state) {
    return new VectorVec3(opensimSimulationJNI.Smith2018ArticularContactForce_getCastingRegionalCenterOfProximity(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public Vec3 getTargetTotalCenterOfPressure(State state) {
    return new Vec3(opensimSimulationJNI.Smith2018ArticularContactForce_getTargetTotalCenterOfPressure(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public Vec3 getCastingTotalCenterOfPressure(State state) {
    return new Vec3(opensimSimulationJNI.Smith2018ArticularContactForce_getCastingTotalCenterOfPressure(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public VectorVec3 getTargetRegionalCenterOfPressure(State state) {
    return new VectorVec3(opensimSimulationJNI.Smith2018ArticularContactForce_getTargetRegionalCenterOfPressure(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public VectorVec3 getCastingRegionalCenterOfPressure(State state) {
    return new VectorVec3(opensimSimulationJNI.Smith2018ArticularContactForce_getCastingRegionalCenterOfPressure(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public Vec3 getTargetTotalContactForce(State state) {
    return new Vec3(opensimSimulationJNI.Smith2018ArticularContactForce_getTargetTotalContactForce(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public Vec3 getCastingTotalContactForce(State state) {
    return new Vec3(opensimSimulationJNI.Smith2018ArticularContactForce_getCastingTotalContactForce(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public VectorVec3 getTargetRegionalContactForce(State state) {
    return new VectorVec3(opensimSimulationJNI.Smith2018ArticularContactForce_getTargetRegionalContactForce(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public VectorVec3 getCastingRegionalContactForce(State state) {
    return new VectorVec3(opensimSimulationJNI.Smith2018ArticularContactForce_getCastingRegionalContactForce(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public Vec3 getTargetTotalContactMoment(State state) {
    return new Vec3(opensimSimulationJNI.Smith2018ArticularContactForce_getTargetTotalContactMoment(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public Vec3 getCastingTotalContactMoment(State state) {
    return new Vec3(opensimSimulationJNI.Smith2018ArticularContactForce_getCastingTotalContactMoment(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public VectorVec3 getTargetRegionalContactMoment(State state) {
    return new VectorVec3(opensimSimulationJNI.Smith2018ArticularContactForce_getTargetRegionalContactMoment(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public VectorVec3 getCastingRegionalContactMoment(State state) {
    return new VectorVec3(opensimSimulationJNI.Smith2018ArticularContactForce_getCastingRegionalContactMoment(swigCPtr, this, State.getCPtr(state), state), true);
  }

  public double computePotentialEnergy(State state) {
    return opensimSimulationJNI.Smith2018ArticularContactForce_computePotentialEnergy(swigCPtr, this, State.getCPtr(state), state);
  }

  public void computeForce(State state, VectorOfSpatialVec bodyForces, Vector generalizedForces) {
    opensimSimulationJNI.Smith2018ArticularContactForce_computeForce(swigCPtr, this, State.getCPtr(state), state, VectorOfSpatialVec.getCPtr(bodyForces), bodyForces, Vector.getCPtr(generalizedForces), generalizedForces);
  }

  public ArrayDouble getRecordValues(State s) {
    return new ArrayDouble(opensimSimulationJNI.Smith2018ArticularContactForce_getRecordValues(swigCPtr, this, State.getCPtr(s), s), true);
  }

  public ArrayStr getRecordLabels() {
    return new ArrayStr(opensimSimulationJNI.Smith2018ArticularContactForce_getRecordLabels(swigCPtr, this), true);
  }

}
